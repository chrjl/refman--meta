---
tags:
  - knex
  - sqlite
---

# SQLite storage backend

## Data tier

The collections database has three tables: `collection`, `trash`, and `keywords`. It is anticipated that most queries will fall under one of the following: retrieval of URL, keyword search.

### Database schema

The `items` and `trash` tables have the same shape: dedicated columns for title and url and a `details` column of [JSON format](https://www.sqlite.org/json1.html) to flexibly store all other data (e.g. `type` + `entrysubtype`, `aliases`, etc.).

- `key`: primary key
- `title`
- `url`
- `details` (JSON)

The primary key in the `items` table autogenerates (autoincrements). When trashed, the entry inserted into the `trash` table carries its primary key over from the the `items` table.

Keywords are separately managed in the `keywords` table and should not be stored in the `collecton` table. The `keywords` table stores one row per keyword per item (`key`) to allow for easy querying of items by keyword, as well as renaming or dumping all keywords. The table also has a unique index set on it to prevent duplicate (`item_key`, `keyword`) entries

Items are expected to have one alias each, so the `ids` field is stored in the `details` column (as a single component array). If it turns out that items regularly have more than one alias, `ids` can be managed as a separate table, in the same manner as `keywords`.

#### Delete to trash procedure

On delete/trash, the table row is deleted from the `items` table and inserted in its entirety into the `trash` table, including its primary key. This allows the item to remain indexed and searchable in keyword searches (until purged). Keywords are maintained in `keywords` table until purged.

On restore, the item entry will be given a new primary key in the `items` table. Corresponding rows in the `keywords` table will need to be updated to reflect the new `item_key`.

### Migrations

The SQLite dev schema is created and managed by `knex.js` migrations. `knex.js` seeds were used to import data from the [[json-backend]] branch.

- Migration: create tables `collection`, `trash`, `keywords`
- Seed: `collection` and `keywords`

## API server

### Implemented routes

> **Note:**
> View the [OpenAPI specification](assets/v1.openapi.json) or an export of the [Swagger UI](https://github.com/chrjl).

| Route                   | Method                          |
| ----------------------- | ------------------------------- |
| `/openapi.json`         |                                 |
| `/items`                | `GET`, `POST`, `DELETE`         |
| `/items?format=archive` | `GET`                           |
| `/items/trash`          | `GET`, `DELETE`                 |
| `/items/{itemKey}`      | `GET`, `PUT`, `PATCH`, `DELETE` |
| `/items/{itemKey}/tags` | `GET`, `PATCH`, `DELETE`        |
| `/tags`                 | `GET`, `DELETE`                 |
| `/tags/{tag}`           | `POST`                          |

### Differences from `v0` (`json-backend`) API

`key` is never provided in request body.

- The primary key is autogenerated (autoincremented) by the database and is silently ignored if provided in the request body.
- When it is necessary to specify the primary key of an item, it will always be via path or query parameter (`itemKey`).

`POST /items` will always create a new item with autoincremented primary key (`key` field), given valid input, and return the `key` as its response.

- There is no `403 Forbidden` error as path traversal is no longer an issue.
- `409 Conflict` will be returned if the requests attempts to set the `key` field. `key` is a forbidden field as it is autogenerated by the database.

`PATCH /item/{itemKey}`

- Does not allow updating of keywords.
- Uses SQLite `json_patch` to update fields in the `details` column.

  > **Note:** `json_set`, `json_insert`, `json_replace` update a single key.
  >
  > `json_set` overwrites a value that already exist, and creates a new key for a value that does not exist. `json_insert` does not overwrite existing values. `json_replace` does not create values that do not already exist.

Keyword searches and operations are implemented.

- To add a keyword to (or delete a keyword from) an item, use the `/items/{itemKey}/tags` route (`PATCH` or `DELETE`).
- `PUT /item/{itemKey}` performs a full update on keywords.
