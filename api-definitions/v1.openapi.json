{"openapi":"3.0.0","info":{"version":"1.0.0","title":"refman v1 (sqlite backend)","description":"Storage in SQLite, CRUD operations via Knex.js (server `1fb2175`)","license":{"name":null}},"servers":[{"url":"/v1","description":"sqlite"}],"externalDocs":{"description":"Read more...","url":"https://github.com/chrjl/refman--docs/wiki/sqlite-backend"},"paths":{"/items":{"get":{"summary":"All items in the collection, excluding trashed items.","description":"Get items and join keywords.\n\n```sql\nSELECT\n    items.*,\n    group_concat(keywords.keyword) AS keywords\nFROM\n    items\n    LEFT OUTER JOIN keywords\n    ON items.key = keywords.item_key\nGROUP BY\n    keywords.item_key;\n```\n\nWithout query, returns all items in collection. Supported queries:\n\n- `itemKeys`\n  : return the requested subset of items.\n\n  ```sql\n  WHERE\n      items.key IN ({...itemKey})\n  ```\n\n- `tags`\n  : return the items that match the tag search (see tag search syntax).\n\n  - OR\n\n    ```sql\n    WHERE\n        keywords.keyword IN ({...tag})\n    ```\n\n  - AND\n    : first, collect the `itemKey`s that match the search.\n\n    ```sql\n    WHERE\n        item_key IN (\n            SELECT\n                item_key \n            FROM\n                keywords\n            WHERE\n                keyword IN {...tag[0]}\n            INTERSECT\n            SELECT\n                item_key \n            FROM\n                keywords\n            WHERE\n                keyword IN {...tag[1]}\n        )\n    ```\n\n- `format`\n  : returns an attachment of all data.\n\n---\n\n> ***Note:***\n> Mixing queries of different keys is not supported. Will return an error.\n","tags":["#development[items]","feature(archive)"],"parameters":[{"in":"query","name":"format","schema":{"type":"string","enum":["json","archive"]},"description":"`json` (default) will return a JSON array of all items\n\n`archive` will return a `.**filetype**` archive of the collection database\n- Set the `Content-Type` header to `application/**filetype**`\n- Set the `Content-Disposition` header to set the attachment filename.\n- How is the archive created?\n"},{"in":"query","name":"itemKey","description":"Comma-separated list of item `key`s"},{"in":"query","name":"tag","description":"Search syntax (URL-encoded search strings):\n\n- &#x2610;\n  : `tag=foo`\n\n- &#x2610; OR\n: `tag=foo || bar`\n\n- &#x2610; AND\n  : `tag=foo || bar&tag=baz`\n\n- &#x2610; NOT\n  : `tag=-foo`\n"}],"responses":{"200":{"content":{"application/json":{"schema":{"type":"array","example":[]}}}},"400":{"description":"Bad request due to invalid/unsupported query."},"404":{"description":"`ENOENT` database file (Not Found)"}}},"delete":{"summary":"Delete multiple items (to trash).","tags":["#development[items]"],"description":"In a transaction:\n\n- Delete items from collection, returning item entries\n\n  ```sql\n  DELETE FROM items\n  WHERE\n      key IN ({itemKey[0]}, {itemKey[1]}, {itemKey[2]});\n  RETURNING *;\n  ```\n\n- Create item entries in the trash table, reusing the (autogenerated) key from the collection table.\n\n  ```sql\n  INSERT INTO trash\n  VALUES\n      (items[0].key, items[0].title, items[0].url, items[0].details),\n      (items[1].key, items[1].title, items[1].url, items[1].details),\n      (items[2].key, items[2].title, items[2].url, items[2].details);\n  ```\n\n- Keep keywords in table to allow them to remain searchable until purged.\n","parameters":[{"in":"query","name":"itemKey","description":"Comma-separated list of item `key`s.","required":true,"allowReserved":true}],"responses":{"204":{"description":"The items were deleted (No Content)"},"400":{"description":"No `itemKeys` were provided (Bad Request)"}}},"post":{"summary":"Create an item","description":"Preprocess request body: `const {title, url, keywords, ...details} = req.body`.\n\nIn a transaction:\n- Insert item, returning `key`\n\n  ```sql\n  INSERT INTO\n      items (title, url, details)\n  VALUES\n      (<title>, <url>, <details>)\n  RETURNING\n      key AS item_key;\n  ```\n\n- Insert keywords\n\n  ```\n  INSERT INTO\n      keywords (item_key, keyword)\n  VALUES\n      (<item_key>, keywords[0]),\n      (<item_key>, keywords[1]),\n      (<item_key>, keywords[2]);\n  ```\n\n---\n\n> **Note:**\n> The server will return an error if a `key` field is included as part of the new item. The primary `key` is intended to be autogenerated by the database and returned in the server response.\n","tags":["#development[items]"],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Item"},"examples":{"example-201":{"value":{"title":"example title","exampleField":"example value"}},"example-400-empty":{"description":"Request body has no data.","value":{}},"example-400-key":{"$ref":"#/components/examples/example-400-key"},"example-400-syntax":{"$ref":"#/components/examples/example-400-syntax"}}}}},"responses":{"201":{"description":"The request completed, returning the primary key of the created item. (Created)","content":{"application/json":{"type":"object","example":{"key":"example"}}}},"400":{"description":"`ERR_INVALID_ARG_TYPE` (Bad Request)"}}}},"/items/{itemKey}":{"get":{"tags":["#development[items]"],"summary":"A specific item in the collection.","description":"```sql\nSELECT\n    items.*,\n    group_concat(keywords.keyword) AS keywords\nFROM\n    items\n    LEFT OUTER JOIN keywords\n    ON items.key = keywords.item_key\nGROUP BY\n    keywords.item_key\nWHERE\n    item.key = {itemKey};\n```\n","parameters":[{"$ref":"#/components/parameters/itemKey"}],"responses":{"200":{"content":{"application/json":{"schema":{"type":"object"}}}},"404":{"description":"`ENOENT` item file (Not Found)"}}},"delete":{"tags":["#development[items]"],"summary":"Delete an item (to trash).","description":"In a transaction:\n\n- Delete item from collection, returning row\n\n  ```sql\n  DELETE FROM items\n  WHERE\n      key = {itemKey}\n  RETURNING *;\n  ```\n\n- Create item entry in the trash table, reusing the (autogenerated) key from the collection table.\n\n  ```sql\n  INSERT INTO trash\n  VALUES\n      (item.key, item.title, item.url, item.details),\n  ```\n\n- Keep keywords in table to allow them to remain searchable until purged.\n","parameters":[{"$ref":"#/components/parameters/itemKey"}],"responses":{"204":{"description":"The item was deleted (No Content)"}}},"put":{"summary":"Full-item updating.","description":"Preprocess request body: `const {title, url, keywords, ...details} = req.body`.\n\nIn a transaction:\n\n- Delete the item\n\n  ```sql\n  DELETE FROM items\n  WHERE key = {itemKey}\n  ```\n\n- Insert new data, explicitly setting primary key\n\n  ```sql\n  INSERT INTO items\n  VALUES\n      ( {itemKey}, <title>, <url>, <details> )\n  ```\n\n- Delete keyword entries\n\n  ```sql\n  DELETE FROM keywords\n  WHERE \n    item_key = {item_key};\n  ```\n\n- Insert keyword entries\n\n  ```sql\n  INSERT INTO\n      keywords (item_key, keyword)\n  VALUES\n      (<item_key>, keywords[0]),\n      (<item_key>, keywords[1]),\n      (<item_key>, keywords[2]);\n  ```\n\n---\n\n> **Note:**\n> The server will return an error if a `key` field is included as part of the new item. Reference to the the primary key is via the `itemKey` path parameter.\n","tags":["#development[items]"],"parameters":[{"$ref":"#/components/parameters/itemKey"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Item"},"examples":{"example-OK":{"$ref":"#/components/schemas/Item/example"},"example-400-key":{"$ref":"#/components/examples/example-400-key"},"example-400-syntax":{"$ref":"#/components/examples/example-400-syntax"}}}}},"responses":{"204":{"description":"The item was successfully updated (No Content)"},"400":{"description":"Invalid type/field; unparseable JSON (Bad Request)"},"404":{"description":"`ENOENT` (Not Found)"}}},"patch":{"summary":"Partial-item updating","description":"Preprocess request body: `const {title, url, keywords, ...details} = req.body`.\n\n- Throw an error if attempting to update keywords.\n\nIn a transaction:\n\n- If `title` or `url` fields are provided, update the `items` table.\n\n  ```sql\n  UPDATE items\n  SET\n      title = {title},\n      url = {url}\n  WHERE\n      key = {itemKey}\n  ```\n\n- If any details fields are provided, update `details` json in the `items` table.\n\n  ```sql\n  UPDATE items\n  SET\n      details = json_patch(details, {details})\n  WHERE\n      key = {itemKey}\n  ```\n\n---\n\n> **Note:**\n> The server will return an error if a `key` field is included as part of item updates. Reference to the the primary key is via the `itemKey` path parameter.\n\n> **Note:**\n> The server will return an error if a `keywords` field is included as part of item updates. Patch updates to keywords is performed via the `/items/{itemKey}/keywords` route.\n","tags":["#development[items]"],"parameters":[{"$ref":"#/components/parameters/itemKey"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object"},"examples":{"example-OK":{"value":{"title":"updated title","url":"updated url","urldate":"updated urldate","newDetail":"new detail field"}},"example-400-keywords":{"value":{"keywords":["keyword1","keyword2"]}},"example-400-key":{"$ref":"#/components/examples/example-400-key"},"example-400-syntax":{"$ref":"#/components/examples/example-400-syntax"}}}}},"responses":{"204":{"description":"The item was successfully updated (No Content)"},"400":{"description":"Invalid type/field; unparseable JSON (Bad Request)"},"404":{"description":"`ENOENT` (Not Found)"}}}},"/items/{itemKey}/tags":{"get":{"tags":["#development[tags]"],"summary":"Keywords associated with a specific item.","description":"```sql\nSELECT\n    keyword\nFROM\n    keywords\nWHERE\n    item_key = {itemKey};\n```\n","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"type":"object"},"examples":{"example":{"$ref":"#/components/examples/response-keywords"}}}}}}},"patch":{"tags":["#development[tags]"],"summary":"Attach keywords to an item.","description":"```sql\nINSERT OR IGNORE INTO \n    keywords (item_key, keyword)\nVALUES\n    ({item_key}, {tag[0]}),\n    ({item_key}, {tag[1]}),\n    ({item_key}, {tag[2]});\n```\n\n---\n\n> **Note:**\n> To update all keywords of an item, use the `PUT /items/{itemKey}` method\n\n> **Note:**\n> Duplicate (`itemKey`, `keyword`) entries are avoided via the `UNIQUE INDEX` constraint.\n","parameters":[{"$ref":"#/components/parameters/tag"}],"responses":{"204":{"description":"The items were successfully updated to reflect the new keywords. (No Response)"},"400":{"description":"Missing required parameter. (Bad Request)"}}},"delete":{"tags":["#development[tags]"],"summary":"Remove reference to keywords from an item.","description":"```sql\nDELETE FROM keywords\nWHERE\n    item_key = {item_key} \n    AND keyword in ({tag[0]}, {tag[1]}, {tag[2]})\n```\n","parameters":[{"$ref":"#/components/parameters/tag"}],"responses":{"204":{"description":"The keywords were deleted from the item. (No Response)"},"400":{"description":"Missing required parameter. (Bad Request)"}}}},"/items/trash":{"get":{"summary":"Items in the trash.","description":"```sql\nSELECT\n    items.*,\n    group_concat(keywords.keyword) AS keywords\nFROM\n    trash\n    LEFT OUTER JOIN keywords\n    ON trash.key = keywords.item_key\nGROUP BY\n    trash.item_key;\n```\n","tags":["#development[trash]"],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"type":"array","example":[]}}}}}},"delete":{"summary":"Purge items from the trash, along with their corresponding keywords entries.","description":"In a transaction:\n\n- Delete trash items, returning keys. Default behavior is purge all items from trash.\n\n  ```sql\n  DELETE FROM trash\n  RETURNING key AS purged_key;\n  ```\n\n  If a list of `itemKey`s is provided as a query parameter, only those items will be purged.\n\n  ```sql\n  WHERE key IN {...itemKey};\n  ```\n\n- Delete keyword entries\n\n  ```\n  DELETE FROM keywords\n  WHERE\n      item_key IN purged_key;\n  ```\n","tags":["#development[trash]"],"parameters":[{"in":"query","name":"itemKey","required":false,"schema":{"type":"string"},"description":"Comma-separated list of item `keys`."}],"responses":{"204":{"description":"The items were purged from trash. (No Response)"},"400":{"description":"Missing required parameters. (Bad Request)"}}}},"/tags":{"get":{"summary":"All keywords in the collection.","description":"```sql\nSELECT DISTINCT\n    keyword \nFROM\n    keywords;\n```\n","tags":["#development[tags]"],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"type":"object"},"examples":{"example":{"$ref":"#/components/examples/response-keywords"}}}}}}},"delete":{"summary":"Delete (all references to) a list of keywords.","description":"```sql\nDELETE FROM keywords\nWHERE \n    keyword IN ({tag[0]}, {tag[1]}, {tag[2]})\n```\n","tags":["#development[tags]"],"parameters":[{"$ref":"#/components/parameters/tag"}],"responses":{"204":{"description":"The items were deleted. (No Content)"},"400":{"description":"Missing required parameter. (Bad Request)'"}}}},"/tags/{tag}":{"post":{"summary":"Perform operations on a specific keyword.","description":"Operation details are to be supplied by header parameters. Data can be sent in request body.\n\nSupported operations:\n\n- Rename an existing keyword, emulating the WebDAV `MOVE` method. The new name of the keyword is passed to the `Destination` header.\n\n  ```sql\n  UPDATE OR REPLACE keywords\n  SET\n      keyword = {tag}\n  WHERE\n      keyword = {Destination}\n  ```\n\n  The new name does not have to be unique. A keyword can be renamed such that its associated items are absorbed by an already existing keyword.\n\n  ---\n\n> **Note:**\n> Duplicate (`itemKey`, `keyword`) entries are avoided via the `UNIQUE INDEX` constraint.\n","tags":["#development[tags]"],"parameters":[{"in":"header","name":"X-HTTP-Method-Override","description":"Emulates selected WebDAV methods.","required":true,"schema":{"type":"string","default":"MOVE","enum":["MOVE","405_NOT_ALLOWED"]}},{"in":"header","name":"Destination","schema":{"type":"string"},"description":"Required if `MOVE` method is selected.\n"}],"responses":{"204":{"description":"The keyword was successfully renamed. (No Response)","headers":{"Location":{"schema":{"type":"string"}}}},"400":{"description":"Missing required parameter. (Bad Request)"},"404":{"description":"Keyword not found. (Not Found)"},"405":{"description":"The requested operation is not allowed. (Method Not Allowed)"}}}}},"components":{"examples":{"example-400-key":{"value":{"key":400},"description":"Request body illegally specifies primary key."},"example-400-syntax":{"value":"bad syntax","description":"Request body is not valid JSON."},"response-keywords":{"value":{"keywords":["nodejs","express","rest","openapi"]}}},"parameters":{"itemKey":{"in":"path","name":"itemKey","required":true,"schema":{"type":"string"},"description":"The item's primary key.","examples":{"example-OK":{"value":100},"example-404":{"value":-1}}},"tag":{"in":"query","name":"tag","schema":{"type":"string"},"description":"Comma-separated list of keywords.","required":true,"default":"tag1,tag2"}},"schemas":{"Item":{"type":"object","required":["ids","url"],"properties":{"key":{"type":"string","description":"Autogenerated (autoincremented) by database.\nWill be silently ignored if provided in request body (provide as path parameter when necessary).\n"},"ids":{"type":"list","description":"BibLaTeX ids"},"url":{"type":"uri"},"keywords":{"type":"list"},"type":{"type":"string"},"entrysubtype":{"type":"string","description":"for use with @online type"},"author":{"type":"list"},"publisher":{"type":"list"},"title":{"type":"string"},"date":{"type":"string"},"urldate":{"type":"string","description":"access date"}},"example":{"value":{"title":"Express web framework (Node.js/JavaScript)","author":["MDN"],"publisher":["MDN"],"url":"https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs","type":"online","entrysubtype":"collection","date":"2022-09-09","urldate":"2023-01-11","ids":["MDN_express"]}}}}},"tags":[]}